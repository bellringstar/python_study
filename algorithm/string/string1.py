'''
글자 A를 메모리에 저장하는 방법
메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한
각 문자에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법을 사용
ex) 영어 52개 = 6비트면 사용 가능
이를 위한 표준안 = ASCII 아스키코드
영어 뿐만 아니라 다국어 처리를 위한 표준 = 유니코드
유니코드 인코딩 UTF(Unicode Transformation Format) 
UTF-8(web): Min 8bit Max 32bit /UTF-8(windows, java): Min 16bit Max 32bit
파이썬의 경우 UTF-8
문자열
1.고정길이 문자열
2.가변길이 문자열
2-1.길이조절 문자열(Java)
2-2.구분자 문자열(C)

패턴 매칭 알고리즘 : 본문에서 특정한 문자열을 찾는것
1. 고지식한 패턴 검색 알고리즘(Brute Force)
본문 문자열을 처음부터 끝까지 순회하면서 패턴 내의 문자들을 일일이 비교
비교하다 틀리다 -> 한 칸 이동-> 비교
p = 'is' #찾을 패턴
t = 'This is a book~!' #전체 텍스트
M = len(p)
N = len(t)
def BruteForce(p, t):
    i = 0 #t의 인덱스
    j = 0 #p의 인덱스
    while j<M and i<N:
        if t[i]!=p[j]:
            i = i-j
            j = -1
        i += 1
        j += 1
    if j == M : return i - M #검색 성공
    else: return -1 #검색 실패
O(MN)
2. KMP 알고리즘
불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로,
불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
패턴을 전처리하여 배열 next[M]을 구해 잘못된 시작을 최소화함
next[M]: 불일치가 발생했을 경우 이동할 다음 위치
O(M+N)
매칭에 실패했을시 돌아갈 곳을 미리 계산
3. 보이어-무어 알고리즘
오른쪽에서 왼쪽으로 비교, 대부분의 상용 소프트웨어에서 채택
패턴에 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 패턴의 길이 만큼이 됨
skip 배열 ex) rithm = m,h,t,i,r,다른 모든문자 
a pattern vs rithm 비교 m부터 -> m과 t가 동일 위치 = 다르다 =스킵배열에서 t의 위치 2 -> 2칸 스킵
문자열 매칭 알고리즘 비교
찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
고지식한 패턴 검색 알고리즘 O(mn)
카프-라빈 알고리즘  O(n)
KMP 알고리즘 O(n)
보이어-무어 알고리즘 최악의 경우 O(mn) 하지만 일반적으로 O(n)보다 적음
'''