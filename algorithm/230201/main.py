'''
알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
슈도코드를 사용해 표현하는 법을 연습
좋은 알고리즘
1. 정확성
2. 작업량
3. 메모리 사용량
4. 단순성
5. 최적성

반복해서 풀어보자
문제풀이 단계
1. 문제 읽기 -> 중요한 부분 뽑아 조건/제약 체크 -> 손으로 풀어보며 구상하기(순차적 사고)
문제풀이가 어느 정도를 넘어서지 못한다 -> 정독 -> 새출발
2. 접근방법 구상 ->  유형판단보다는 난이도를 고려해서 복잡도 생각 ex)A형인데 너무 단순하다? ->다른 방법 구상
2-1. 완전히 새로운 문제는 없다 -> 경험을 많이 쌓자
2-2. 문제가 시키는 대로 시도한다.
문제설명대로 예시를 처리하는 것이 가능한다(제약조건 내)
여러 입력에 대한 출력을 계산하면서 [규칙성/조건/수식] 적용 가능한지 체크
2-3. 유형/규칙성을 발견하기 힘들다면...
가능한 모든 경우를 처리하면서 풀이 가능한지 체크
전체 문제가 아닌 일부분으로 나누거나, 단계를 나누어 접근
반대로 접근하는 경우를 체크
2-4. 모든 접근은 시각적으로(손으로 그리면서)
3. 핵심코드 손코딩 -> 손풀기를 보며 손코딩 -> 변수명,범위를 구체적으로 쓴다.
4. 코드구현 -> 오타조심, 한동작이 한눈에 보이도록
5. 디버깅 및 개선

배열
메모리에 같은이름으로 연속성있게 저장하는것
하나의 변수명으로 다양한 자료를 관리

입출력을 제외한 내장함수 사용금지

가능하면 배열은 크기를 정해놓고 생성한 뒤 풀자. append는 최소화

1. 버블정렬
인접한 두 값을 비교해 교환해가며 맨 마지막 자리까지 이동
그럼 마지막 자리는 고정, 한 사이즈 작은 배열에 다시 정렬을 반복
'''


# blocks = [7, 4, 2, 0, 0, 6, 0, 7, 0]
# N = len(blocks)

# for i in range(0, N):
#     cnt = 0
#     for j in range(i+1, N):
#         if blocks[i] > blocks[j]:
#             cnt += 1
#     print(cnt)

# curMaxV = 0
# res = [0] * N
# for i in range(0, N):
#     cnt = 0
#     for j in range(i+1, N):
#         if blocks[i] > blocks[j]:
#             cnt +=1
#
#     if curMaxV < cnt:
#         curMaxV = cnt
#
# print(curMaxV)


