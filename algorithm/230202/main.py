'''
Counting Sort
O(n+k) : n은 리스트의 길이, k는 정수의 최대값 둘 중 영향이 큰 것에
집합에 항목이 몇 개씩 있는지 count해 선형 시간에 정렬
하지만 가장 큰 수의 크기만큼 count array를 만들어야 해서 [1,4001]같은 경우 4001사이즈의 배열이 필요 -> 비효율
array의 인덱스를 사용 -> 정수형 자료에서만 가능
카운트 후 누적합 계산 count[i] <- count[i-1] + count[i] sequential 위치를 찾기 위해
DATA = [0, 4, 1, 3, 1, 2, 4, 1] 정렬
count = [1,3,1,1,2] -> [1,4,5,6,8] ex)2(idx) 앞에 4개가 있다.
누적합 = 해당 값의 시작위치를 알기 위해 ex) count[4] = 8 : temp의 8번쨰 위치(idx = 7)부터 4가 시작된다.
TEMP = 원본과 같은 크기의 어레이 정렬 후 저장. 
DATA의 뒤에서부터 데이터를 읽어온다. ex) 1 -> count idx 1인 위치를 찾아간다. = 4 => 1까지 총 4개의 수가 있다.
=> 적어도 4번째 자리(idx = 3)에 1이 있다. 1을 TEMP에 넣고 count 1감소
DATA에서 한칸 앞으로 이동해서 반복. 1회 시행마다 1개의 위치가 고정.
같은 값일 떄 원본의 순서가 바뀌지 않고 다시 정렬 = 안정정렬 = 뒤에서부터 가는 이유
'''

# def Counting_Sort(A, B, k):
#     #A [] 입력배열 (0 to k)
#     #B [] 정렬된 배열
#     #C [] 카운트 배열
#     k = max(A)
#     c = [0] * (k+1)
#     for i in range(0, len(A)):
#         C[A[i]] += 1
#     for i in range(1, len(C)):
#         C[i] += C[i-1]
#     for i in range(len(B)-1, -1, -1):
#         C[A[i]] -= 1
#         B[C[A[i]]] = A[i]
'''
Baby-gin Game
0~9까지의 숫자카드에서 임의의 6장을 뽑았을때 3장의 카드가 연속번호 = run, 3장의 카드 동일한 번호 = triplet
6장의 카드가 run과 triplet으로만 구성된 경우 = baby-gin
6자리 숫자를 입력받아 baby-gin 여부 판단 프로그램

완전검색 기법
모든 경우의 수 나열 -> 확인
Brute-force라고 부르기도 한다.
경우의수가 작을 때 유용
수행 속도는 느리지만 해답을 찾을 확률은 높다.
일단 풀고 성능개선을 위한 다른 알고리즘 적용이 좋다.
경우의 수 계산을 통해 완전검색을 할 수 있을 것인가를 고려 대충 10억번 계산 = 1초
ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
'''
# for i1 in range(1,4):
#     for i2 in range(1,4):
#         if i2 != i1 :
#             for i3 in range(1,4):
#                 if i3 != i1 and i3 != i2:
#                     print(i1, i2, i3)

'''
# num = 456789
# c = [0] * 12 #더미를 더 많들어 범위를 구분하지 않고 검사할 수 있다.
# for i in range(6):
#     c[num % 10] += 1
#     num //= 10
i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3: #triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue
    if c[i] >=1 and c[i+1] >= 1 and c[i+2] >=1: #run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1
if run + tri == 2 : print('Baby Gin')
else: print('Lose')
'''

'''
Greedy 알고리즘
최적해를 구하는 데 사용되는 근시안적인 방법
여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
각 선택은 그 선택 시점에서는 최적일 수 있지만 그 결정들을 모아 최종 답을 만들었따고 해서 그것이 최적이라는 보장은 없다.
1. 해 선택: 현재 상태에서 부분 문제의 최적해를 구한 뒤 부분해 집합에 추가한다.
2. 실행 가능성 검사: 문제 제약조건
3. 해 검사
ex) 거스름돈 줄이기
1. 500워부터 준다 = 그리디 알고리즘, 당장의 최적해
2. 실행가능성: 만약 거스름돈이 300원이라면?
3. 해검사: 거스름돈에 맞게 줬느냐


'''
